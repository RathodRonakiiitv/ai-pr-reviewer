name: AI Code Review

on:
  pull_request:
    types: [opened, synchronize, reopened]
  workflow_dispatch:
    inputs:
      exclude_files:
        description: 'Glob patterns to exclude (comma separated)'
        default: '**/*.lock, **/*.min.js, **/*.map, **/node_modules/**'
      strictness:
        description: 'Review strictness (low, medium, high)'
        default: 'medium'
      max_file_size:
        description: 'Max characters per file to review'
        default: '6000'

permissions:
  contents: read
  pull-requests: write

jobs:
  review:
    runs-on: ubuntu-latest
    name: AI Code Review
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get PR Diff and Review
        uses: actions/github-script@v7
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
        with:
          script: |
            const core = require('@actions/core');
            const glob = require('@actions/glob');
            
            core.info('=== Starting AI Code Review (Portfolio Grade) ===');
            
            // Configuration
            const excludePatterns = (context.payload.inputs?.exclude_files || '**/*.lock, **/*.min.js, **/*.map, **/node_modules/**').split(',').map(s => s.trim());
            const strictness = context.payload.inputs?.strictness || 'medium';
            const maxFileSize = parseInt(context.payload.inputs?.max_file_size || '6000');
            const apiKey = process.env.GEMINI_API_KEY;
            
            if (!apiKey) {
              core.setFailed('âŒ GEMINI_API_KEY secret is not set.');
              return;
            }

            // --- Helper: Check exclusions using minimatch logic via @actions/glob ---
            async function isExcluded(filename) {
                const globber = await glob.create(excludePatterns.join('\n'));
                const files = await globber.glob();
                // This is a simplified check; for precise PR file matching without filesystem we'd use minimatch, 
                // but here we can check basic extensions or just rely on the API filter + size check.
                // For this demo, let's strictly stick to extension/name checks to be safe without full minimatch lib.
                if (filename.endsWith('.lock') || filename.endsWith('.min.js') || filename.includes('node_modules')) return true;
                return false;
            }

            // Post initial status
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: `## ðŸ¤– AI Code Review\n\nðŸ”Ž Analyzing changes... \n*Config: Strictness=${strictness}*`
            });
            
            // Get changed files
            const { data: files } = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            });
            
            // --- Engineering: Context Management & Filtering ---
            const supportedExtensions = ['.js', '.ts', '.jsx', '.tsx', '.py', '.java', '.cpp', '.go', '.rs', '.html', '.css'];
            let filesToReview = [];
            let skippedFiles = [];

            for (const file of files) {
                const isSupported = supportedExtensions.some(ext => file.filename.endsWith(ext));
                const excluded = await isExcluded(file.filename);
                
                if (isSupported && !excluded) {
                    if (file.patch && file.patch.length > maxFileSize) {
                        skippedFiles.push(`${file.filename} (Too large: ${file.patch.length} chars)`);
                    } else {
                        filesToReview.push(file);
                    }
                }
            }

            if (filesToReview.length === 0) {
                let msg = 'âœ… No reviewable code changes found.';
                if (skippedFiles.length > 0) msg += `\n(Skipped ${skippedFiles.length} large files)`;
                await github.rest.issues.createComment({
                    owner: context.repo.owner, repo: context.repo.repo, issue_number: context.issue.number,
                    body: `## ðŸ¤– AI Code Review\n\n${msg}`
                });
                return;
            }

            // --- Prompt Engineering: Structured Output ---
            let diffContext = '';
            for (const file of filesToReview) {
                diffContext += `\n### File: ${file.filename}\n\`\`\`diff\n${file.patch}\n\`\`\`\n`;
            }

            const prompt = `
            You are an expert Senior Staff Engineer doing a code review.
            Strictness Level: ${strictness.toUpperCase()}

            INSTRUCTIONS:
            1. Analyze the code for Bugs, Security Vulnerabilities, and Clean Code violations.
            2. context is limited, so only comment on what you see in the diff.
            3. IGNORE minor style/whitespace issues unless strictness is HIGH.
            4. FORMAT YOUR RESPONSE using the structure below.

            STRUCTURE:
            ## ðŸ”Ž Review Summary
            [1-2 sentences overall thought]

            ## ðŸ”´ Critical Issues (Bugs/Security)
            - [File.py]: Description of bug...

            ## âš ï¸ Improvements (Refactoring/Perf)
            - [File.js]: Suggestion...

            ## â„¹ï¸ Nitpicks (Docs/Style)
            - [File]: Description...

            CODE DIFF:
            ${diffContext}
            `;

            // Call API
            const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    contents: [{ parts: [{ text: prompt }] }],
                    generationConfig: { temperature: 0.3 } // Lower temperature for more factual reviews
                })
            });

            const data = await response.json();
            
            // Error Handling
            if (data.error) {
                core.setFailed(`API Error: ${data.error.message}`);
                return;
            }

            const review = data.candidates?.[0]?.content?.parts?.[0]?.text || "âŒ No review generated.";
            
            // Add footer about excluded files
            let footer = '';
            if (skippedFiles.length > 0) {
                footer = `\n\n---\n*âš ï¸ Skipped files (too large):* \n${skippedFiles.map(f => `- ${f}`).join('\n')}`;
            }

            await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: review + footer
            });
